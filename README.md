# Домашнее задание к занятию 5 "`Индексы`" - `Падеев Василий`


   
### Задание 1. 


Напишите запрос к учебной базе данных, который вернёт процентное отношение общего размера всех индексов к общему размеру всех таблиц.

Решение...


`При необходимости прикрепитe сюда скриншоты

![answer1](https://github.com/Vasiliy-Ser/homework_11.5/blob/bed6b06cdf2f5698d88718c1b8f1a4f694497e5f/img/11.5.1.png)


---

### Задание 2. 


Выполните explain analyze следующего запроса:

```
select distinct concat(c.last_name, ' ', c.first_name), sum(p.amount) over (partition by c.customer_id, f.title)
from payment p, rental r, customer c, inventory i, film f
where date(p.payment_date) = '2005-07-30' and p.payment_date = r.rental_date and r.customer_id = c.customer_id and i.inventory_id = r.inventory_id
```

- перечислите узкие места;
- оптимизируйте запрос: внесите корректировки по использованию операторов, при необходимости добавьте индексы.

Решение...

Недочеты в запросе:

1. Фильтрация по дате с функцией DATE(): Использование функции DATE() в WHERE на колонке payment_date делает невозможным использование индекса по этой колонке. 

2. Использование DISTINCT требует сортировки или группировки, что может замедлить выполнение.

3. Использование оконной функции SUM() OVER добавляют нагрузку на выполнение, особенно при больших объёмах данных.


`При необходимости прикрепитe сюда скриншоты

![answer2](https://github.com/Vasiliy-Ser/homework_11.5/blob/bed6b06cdf2f5698d88718c1b8f1a4f694497e5f/img/11.5.21.png)
![answer3](https://github.com/Vasiliy-Ser/homework_11.5/blob/bed6b06cdf2f5698d88718c1b8f1a4f694497e5f/img/11.5.22.png)

---


Дополнительные задания (со звёздочкой*)

Эти задания дополнительные, то есть не обязательные к выполнению, и никак не повлияют на получение вами зачёта по этому домашнему заданию. Вы можете их выполнить, если хотите глубже разобраться в материале.

### Задание 3*. 


Самостоятельно изучите, какие типы индексов используются в PostgreSQL. Перечислите те индексы, которые используются в PostgreSQL, а в MySQL — нет.

Приведите ответ в свободной форме.


Решение...


Типы индексов, поддерживаемые PostgreSQL:

```
B-Tree Index
Используется по умолчанию. Эффективен для точного поиска, диапазонных запросов, операций =, <, >, <=, >=, BETWEEN.

Hash Index
Эффективен для точного поиска по равенству =. В PostgreSQL начиная с версии 10 поддерживает WAL (Write-Ahead Logging).

GiST (Generalized Search Tree)
Подходит для данных с многомерной природой, например, геометрических данных, полнотекстового поиска и других специализированных типов.

SP-GiST (Space-Partitioned GiST)
Оптимизирован для данных, имеющих иерархическую или геометрическую структуру.

GIN (Generalized Inverted Index)
Используется для полнотекстового поиска, массивов, JSONB и других структур, которые требуют индексации содержимого коллекций.

BRIN (Block Range INdex)
Эффективен для больших таблиц, где данные логически упорядочены, например, для временных данных.

Expression Index
Индекс на основе выражения. Например, можно индексировать результат функции.

Partial Index
Индексирует только строки, удовлетворяющие определенному условию.

Covering Index
Индексы, которые включают в себя дополнительные столбцы для выполнения запросов только по индексу (PostgreSQL с версии 11).

GiST и GIN с CASTOM Oптимизацией
PostgreSQL позволяет создавать свои собственные типы индексов или расширения для специфичных задач.
```

Индексы, которые есть в PostgreSQL, но отсутствуют в MySQL:

```
GiST (Generalized Search Tree)
MySQL не поддерживает GiST, который используется для пространственных данных, поиска ближайших соседей и других сложных операций.

SP-GiST (Space-Partitioned GiST)
MySQL не имеет аналога для индексации структурированных пространственных данных.

GIN (Generalized Inverted Index)
PostgreSQL использует GIN для массивов, JSONB и полнотекстового поиска. В MySQL для полнотекстового поиска используется отдельный механизм, но индексации массивов или JSON нет.

BRIN (Block Range Index)
Уникальный тип индекса для PostgreSQL, оптимизированный для больших таблиц с упорядоченными данными. В MySQL нет аналогов.

Expression Index
В MySQL нет индексации на основе выражений. PostgreSQL позволяет индексировать вычисляемые значения.

Partial Index
В MySQL отсутствуют частичные индексы, которые индексируют только часть данных на основе заданного условия.
```


`При необходимости прикрепитe сюда скриншоты




 
